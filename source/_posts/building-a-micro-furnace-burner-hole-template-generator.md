---
title: 'Building a "Micro" Furnace: Burner Hole Template Generator'
url: 136.html
id: 136
categories:
  - Uncategorized
date: 2012-07-23 10:55:27
tags:
---

This is an update to an earlier post, sorry for the delay. Long story -- short: I couldn't find my script in my back up files. I wrote this [Processing](http://processing.org/ "processing.org") script to generate templates of intersecting cylinders. Use [Gimp](http://www.gimp.org/ "Gimp"),Â Photoshop , or any image manipulation program that allows you to resize -- Heck you could even use a photocopier. The variables you need to define are the diameter of cylinder 1, 2 and the distance from the axis of cylinder 1 to the axis of cylinder 2. Copy the below code into your own Processing script, adjust the user defined variables, and run it; it will display your requested template. \[slideshow\] \[sourcecode language="text" wraplines="false" collapse="false"\] /* Perpendicular Offset Cylinders' Intersection Template Generator. Define the variables. Run the Processing Script. Resize the resulting image in photoshop. Created By: mu1tit001 www.outlyingoutlier.com #################################################### User Defined Variables #################################################### */ float Cylinder1Diameter = 8; float Cylinder2Diameter = 2; float IntersectionDistance = 3; //IntersectionDistance must be &lt;= (Cylinder1Diameter-Cylinder2Diameter)/2 boolean saveframe = false; //set true to save a tiff file /* #################################################### #################################################### */ int z = 1000; // Width and Height of resulting window. Template cutout1; void setup() { if(saveframe &amp;&amp; IntersectionDistance &lt;= (Cylinder1Diameter-Cylinder2Diameter)/2) { size(z,z); noFill(); strokeWeight(2); stroke(0); background(255); cutout1 = new Template(Cylinder1Diameter,Cylinder2Diameter,IntersectionDistance); cutout1.display(); saveFrame(Cylinder1Diameter +&quot;_&quot;+ Cylinder2Diameter +&quot;_&quot;+ IntersectionDistance +&quot;.tif&quot;); } else if(IntersectionDistance &lt;= (Cylinder1Diameter-Cylinder2Diameter)/2) { size(z,z); noFill(); strokeWeight(2); stroke(0); background(255); cutout1 = new Template(Cylinder1Diameter,Cylinder2Diameter,IntersectionDistance); cutout1.display(); } else { println(&quot;IntersectionDistance must be &lt;= (Cylinder1Diameter-Cylinder2Diameter)/2&quot;); } } void draw() { } class Template { float y,x,arclength,arclengthmin,arclengthmax,arclengthsmall,x2; float a,b,c,r,h,iteration,maxX,maxY,minX,minY,xmin,xmax,scalingfactor,xmid; Template(float Dcylinder1,float Dcylinder2,float IntersectionDistance) { a = IntersectionDistance-(Dcylinder2/2); //min b = IntersectionDistance+(Dcylinder2/2); //max c = Dcylinder1/2; //large pipe radius r = (b-a)/2; h = IntersectionDistance; iteration = 200; } void display() { arclengthmin = c*(asin(a/c)); arclengthmax = c*(asin(b/c)); xmin = (a+0*((b-a)/2001)); xmax = (a+2001*((b-a)/2001)); scalingfactor = ((width-20)/(arclengthmax-arclengthmin)); println(arclengthmin + &quot;,&quot; + arclengthmax +&quot;,&quot;+scalingfactor); translate(-arclengthmin\*scalingfactor+10,height/2); minX = c\*(asin((a+0*((b-a)/2001))/c))\*scalingfactor; maxX = c\*(asin((a+2001*((b-a)/2001))/c))\*scalingfactor; for(int i = 0; i &lt;= 2001; i ++) { x = (i\*((b-a)/2001)); x2 = x-h; arclength = c*(asin((a+i*((b-a)/2001))/c)); y = sqrt(pow(r,2)-pow(a+i*((b-a)/2001)-((a+b)/2),2)); stroke(0); point(arclength\*scalingfactor,y\*scalingfactor); point(arclength\*scalingfactor,-y\*scalingfactor); if (y &gt; sqrt(pow(r,2)-pow(a+(i-2)*((b-a)/2001)-((a+b)/2),2)) &amp;&amp; y &gt; sqrt(pow(r,2)-pow(a+(i+2)*((b-a)/2001)-((a+b)/2),2))) { maxY = y\*scalingfactor; minY = -maxY; xmid = arclength\*scalingfactor; //println(maxY+&quot;,&quot;+xmid); } stroke(0,255,0,25); translate(-(-arclengthmin\*scalingfactor),0); point(x\*scalingfactor,y\*scalingfactor); point(x\*scalingfactor,-y\*scalingfactor); translate((-arclengthmin\*scalingfactor),0); } stroke(0); line(xmid,minY-50,xmid,maxY+50); noFill(); rectMode(CORNERS); rect(minX,minY,maxX,maxY); line(minX-50,0,maxX+50,0); translate(-(-arclengthmin*scalingfactor+10),-height/2); } } \[/sourcecode\]